// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
// Florian Zaruba <zarubaf@iis.ee.ethz.ch>
//
// AUTOMATICALLY GENERATED by occamygen.py; edit the script instead.
// verilog_lint: waive-start line-length

`include "axi/typedef.svh"
`include "register_interface/typedef.svh"
`include "apb/typedef.svh"

package ${name}_pkg;
  localparam int unsigned MaxTransaction = 16;

  // Re-exports
  localparam int unsigned AddrWidth = ${name}_cluster_pkg::AddrWidth;
  localparam int unsigned NarrowUserWidth = ${name}_cluster_pkg::NarrowUserWidth;
  localparam int unsigned WideUserWidth = ${name}_cluster_pkg::WideUserWidth;

  localparam int unsigned NrClustersS1Quadrant = ${nr_s1_clusters};
  localparam int unsigned NrCoresCluster = ${name}_cluster_pkg::NrCores;
  localparam int unsigned NrCoresS1Quadrant = NrClustersS1Quadrant * NrCoresCluster;

  // Memory cut configurations: one per memory parameterization
  typedef ${name}_cluster_pkg::sram_cfg_t sram_cfg_t;

  typedef struct packed {
    sram_cfg_t rocache_tag;
    sram_cfg_t rocache_data;
    ${name}_cluster_pkg::sram_cfgs_t cluster;
  } sram_cfg_quadrant_t;

  typedef struct packed {
    sram_cfg_t dcache_valid_dirty;
    sram_cfg_t dcache_tag;
    sram_cfg_t dcache_data;
    sram_cfg_t icache_tag;
    sram_cfg_t icache_data;
  } sram_cfg_cva6_t;

  typedef struct packed {
    sram_cfg_t spm_narrow;
    sram_cfg_t spm_wide;
    sram_cfg_cva6_t cva6;
    sram_cfg_quadrant_t quadrant;
  } sram_cfgs_t;

  localparam int unsigned SramCfgWidth = $bits(sram_cfg_t);
  localparam int unsigned SramCfgCount = $bits(sram_cfgs_t)/SramCfgWidth;

  typedef struct packed {
    logic [3:0] timer;               // 69 - 72
    logic [31:0] gpio;               // 37 - 68
    logic uart;                      // 36
    logic spim_error;                // 35
    logic spim_spi_event;            // 34
    logic i2c_fmt_watermark;         // 33
    logic i2c_rx_watermark;          // 32
    logic i2c_fmt_overflow;          // 31
    logic i2c_rx_overflow;           // 30
    logic i2c_nak;                   // 29
    logic i2c_scl_interference;      // 28
    logic i2c_sda_interference;      // 27
    logic i2c_stretch_timeout;       // 26
    logic i2c_sda_unstable;          // 25
    logic i2c_trans_complete;        // 24
    logic i2c_tx_empty;              // 23
    logic i2c_tx_nonempty;           // 22
    logic i2c_tx_overflow;           // 21
    logic i2c_acq_overflow;          // 20
    logic i2c_ack_stop;              // 19
    logic i2c_host_timeout;          // 18
    logic ecc_narrow_uncorrectable;  // 17
    logic ecc_narrow_correctable;    // 16
    logic ecc_wide_uncorrectable;    // 15
    logic ecc_wide_correctable;      // 14
    // 4 programmable, 8 HBM (1x per channel)
    logic [12:0] ext_irq;            // 01-13
    logic zero;                      // 00
  } ${name}_interrupt_t;

  localparam logic [15:0] PartNum = 2;
  localparam logic [31:0] IDCode = (dm::DbgVersion013 << 28) | (PartNum << 12) | 32'h1;

  typedef logic [5:0] tile_id_t;

  typedef logic [AddrWidth-1:0] addr_t;
  typedef logic [NarrowUserWidth-1:0] user_narrow_t;
  typedef logic [WideUserWidth-1:0] user_wide_t;

  typedef struct packed {
    logic [31:0] idx;
    logic [47:0] start_addr;
    logic [47:0] end_addr;
  } xbar_rule_48_t;


  typedef xbar_rule_48_t xbar_rule_t;

  /// We reserve hartid `0` for CVA6.
  localparam logic [9:0] HartIdOffset = 1;
  /// The base offset for each cluster.
  localparam addr_t ClusterBaseOffset = ${util.to_sv_hex(cfg["cluster"]["cluster_base_addr"])};
  /// The address space set aside for each slave.
  localparam addr_t ClusterAddressSpace = ${util.to_sv_hex(cfg["cluster"]["cluster_base_offset"])};
  /// The address space of a single S1 quadrant.
  localparam addr_t S1QuadrantAddressSpace = ClusterAddressSpace * NrClustersS1Quadrant;
  /// The base offset of the quadrant configuration region.
  localparam addr_t S1QuadrantCfgBaseOffset = ${util.to_sv_hex(cfg["s1_quadrant"]["cfg_base_addr"])};
  /// The address space set aside for the configuration of each slave.
  localparam addr_t S1QuadrantCfgAddressSpace = ${util.to_sv_hex(cfg["s1_quadrant"]["cfg_base_offset"])};

% for i, rmq in enumerate(remote_quadrants):
  /// Struct for signals to/from remote quadrant ${i}
  typedef struct packed {
    logic [${rmq["nr_clusters"]*rmq["nr_cluster_cores"]-1}:0] mtip;
    logic [${rmq["nr_clusters"]*rmq["nr_cluster_cores"]-1}:0] msip;
  } rmq_${i}_mst_out_t;
% endfor

% if is_remote_quadrant:
  /// Struct for signals to/from remote quadrants
  typedef struct packed {
    logic [${nr_s1_clusters*nr_cluster_cores-1}:0] mtip;
    logic [${nr_s1_clusters*nr_cluster_cores-1}:0] msip;
  } rmq_mst_out_t;
% endif

  ${package}

endpackage
// verilog_lint: waive-off line-length
