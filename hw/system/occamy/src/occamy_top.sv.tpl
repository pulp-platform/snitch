// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>
// Author: Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
//
// AUTOMATICALLY GENERATED by genoccamy.py; edit the script instead.

`include "common_cells/registers.svh"

module occamy_top
  import occamy_pkg::*;
(
  input  logic        clk_i,
  input  logic        rtc_i,
  input  logic        rst_ni,
  input  logic        test_mode_i,
  input  logic [1:0]  chip_id_i,
  input  logic [1:0]  boot_mode_i,
  // pad cfg
  output logic [31:0]      pad_slw_o,
  output logic [31:0]      pad_smt_o,
  output logic [31:0][1:0] pad_drv_o,
  // `uart` Interface
  output logic        uart_tx_o,
  input  logic        uart_rx_i,
  // `gpio` Interface
  input  logic [31:0] gpio_d_i,
  output logic [31:0] gpio_d_o,
  output logic [31:0] gpio_oe_o,
  output logic [31:0] gpio_puen_o,
  output logic [31:0] gpio_pden_o,
  // `serial` Interface
  input  logic        serial_clk_i,
  input  logic [3:0]  serial_data_i,
  output logic [3:0]  serial_data_o,
  // `jtag` Interface
  input  logic        jtag_trst_ni,
  input  logic        jtag_tck_i,
  input  logic        jtag_tms_i,
  input  logic        jtag_tdi_i,
  output logic        jtag_tdo_o,
  // `i2c` Interface
  output logic        i2c_sda_o,
  input  logic        i2c_sda_i,
  output logic        i2c_sda_en_o,
  output logic        i2c_scl_o,
  input  logic        i2c_scl_i,
  output logic        i2c_scl_en_o,
  // `SPI Host` Interface
  output logic        spim_sck_o,
  output logic        spim_sck_en_o,
  output logic [1:0]  spim_csb_o,
  output logic [1:0]  spim_csb_en_o,
  output logic [3:0]  spim_sd_o,
  output logic [3:0]  spim_sd_en_o,
  input        [3:0]  spim_sd_i,

  /// Boot ROM
  output ${soc_regbus_periph_xbar.out_plic.req_type()} bootrom_req_o,
  input  ${soc_regbus_periph_xbar.out_plic.rsp_type()} bootrom_rsp_i,

  /// PCIe Ports
  output  ${soc_wide_xbar.out_pcie.req_type()} pcie_axi_req_o,
  input   ${soc_wide_xbar.out_pcie.rsp_type()} pcie_axi_rsp_i,

  input  ${soc_wide_xbar.in_pcie.req_type()} pcie_axi_req_i,
  output ${soc_wide_xbar.in_pcie.rsp_type()} pcie_axi_rsp_o
  /// HBM2e Ports

  /// HBI Ports
);

  occamy_soc_reg_pkg::occamy_soc_reg2hw_t soc_ctrl_in;
  occamy_soc_reg_pkg::occamy_soc_hw2reg_t soc_ctrl_out;
  // Machine timer and machine software interrupt pending.
  logic mtip, msip;
  // Supervisor and machine-mode external interrupt pending.
  logic [1:0] eip;
  occamy_interrupt_t irq;

  addr_t [${nr_s1_quadrants-1}:0] s1_quadrant_base_addr;
  % for i in range(nr_s1_quadrants):
  assign s1_quadrant_base_addr[${i}] = ClusterBaseOffset + ${i} * S1QuadrantAddressSpace;
  % endfor

  ///////////////////
  //   CROSSBARS   //
  ///////////////////
  ${module}

  /////////////////////////////
  // Narrow to Wide Crossbar //
  /////////////////////////////
  <% soc_narrow_xbar.out_soc_wide \
        .change_iw(context, 3, "soc_narrow_wide_iwc") \
        .change_dw(context, 512, "soc_narrow_wide_dw", to=soc_wide_xbar.in_soc_narrow)
  %>

  //////////
  // PCIe //
  //////////
  assign pcie_axi_req_o = ${soc_wide_xbar.out_pcie.req_name()};
  assign ${soc_wide_xbar.out_pcie.rsp_name()} = pcie_axi_rsp_i;
  assign ${soc_wide_xbar.in_pcie.req_name()} = pcie_axi_req_i;
  assign pcie_axi_rsp_o = ${soc_wide_xbar.in_pcie.rsp_name()};

  //////////
  // CVA6 //
  //////////
  localparam logic [63:0] BootAddr = 'h1000;
  <%
  cva6 = soc_narrow_xbar.in_cva6.copy(name="cva6_axi").declare(context)
  cva6.cut(context, to=soc_narrow_xbar.in_cva6)
  %>
  occamy_cva6 i_occamy_cva6 (
    .clk_i (clk_i),
    .rst_ni (rst_ni),
    .boot_addr_i (BootAddr),
    .hart_id_i ('0),
    .irq_i (eip),
    .ipi_i (msip),
    .time_irq_i (mtip),
    .debug_req_i ('0),
    .axi_req_o (${cva6.req_name()}),
    .axi_resp_i (${cva6.rsp_name()})
  );

  % for i in range(nr_s1_quadrants):
  ////////////////////
  // S1 Quadrants ${i} //
  ////////////////////
  <%
    cut_width = 1
    narrow_in = soc_narrow_xbar.__dict__["out_s1_quadrant_{}".format(i)].cut(context, cut_width, name="narrow_in_cut_{}".format(i))
    narrow_out = soc_narrow_xbar.__dict__["in_s1_quadrant_{}".format(i)].copy(name="narrow_out_cut_{}".format(i)).declare(context)
    narrow_out.cut(context, cut_width, to=soc_narrow_xbar.__dict__["in_s1_quadrant_{}".format(i)])
    wide_in = soc_wide_xbar.__dict__["out_s1_quadrant_{}".format(i)].cut(context, cut_width, name="wide_in_cut_{}".format(i))
    wide_out = soc_wide_xbar.__dict__["in_s1_quadrant_{}".format(i)].copy(name="wide_out_cut_{}".format(i)).declare(context)
    wide_out.cut(context, cut_width, to=soc_wide_xbar.__dict__["in_s1_quadrant_{}".format(i)])
  %>
  occamy_quadrant_s1 i_occamy_quadrant_s1_${i} (
    .clk_i (clk_i),
    .rst_ni (rst_ni),
    .test_mode_i (test_mode_i),
    .tile_id_i (6'd${i}),
    .debug_req_i ('0),
    .meip_i ('0),
    .mtip_i ('0),
    .msip_i ('0),
    .quadrant_narrow_out_req_o (${narrow_out.req_name()}),
    .quadrant_narrow_out_rsp_i (${narrow_out.rsp_name()}),
    .quadrant_narrow_in_req_i (${narrow_in.req_name()}),
    .quadrant_narrow_in_rsp_o (${narrow_in.rsp_name()}),
    .quadrant_wide_out_req_o (${wide_out.req_name()}),
    .quadrant_wide_out_rsp_i (${wide_out.rsp_name()}),
    .quadrant_wide_in_req_i (${wide_in.req_name()}),
    .quadrant_wide_in_rsp_o (${wide_in.rsp_name()})
  );

  % endfor

  ///////////
  // Debug //
  ///////////

  /////////
  // SPM //
  /////////

  /////////////////
  // Peripherals //
  /////////////////
  <% soc_narrow_xbar.out_periph.to_axi_lite(context, "axi_to_axi_lite_periph", to=soc_periph_xbar.in_soc) %>

  <% soc_narrow_xbar.out_regbus_periph.change_dw(context, 32, "axi_to_axi_lite_dw").to_axi_lite(context, "axi_to_axi_lite_regbus_periph").to_reg(context, "axi_lite_to_regbus_periph", to=soc_regbus_periph_xbar.in_axi_lite_periph_xbar) %>

  ///////////////
  //   CLINT   //
  ///////////////
  clint #(
    .AXI_ADDR_WIDTH (${soc_periph_xbar.out_clint.aw}),
    .AXI_DATA_WIDTH (${soc_periph_xbar.out_clint.dw}),
    .AXI_ID_WIDTH (0),
    .NR_CORES (1),
    .axi_req_t (${soc_periph_xbar.out_clint.req_type()}),
    .axi_resp_t (${soc_periph_xbar.out_clint.rsp_type()})
  ) i_clint (
    .clk_i (${soc_periph_xbar.out_clint.clk}),
    .rst_ni (${soc_periph_xbar.out_clint.rst}),
    .testmode_i (1'b0),
    .axi_req_i (${soc_periph_xbar.out_clint.req_name()}),
    .axi_resp_o (${soc_periph_xbar.out_clint.rsp_name()}),
    .rtc_i (rtc_i),
    .timer_irq_o (mtip),
    .ipi_o (msip)
  );

  /////////////////////
  //   SOC CONTROL   //
  /////////////////////
  occamy_soc_reg_top #(
    .reg_req_t ( ${soc_regbus_periph_xbar.out_soc_ctrl.req_type()} ),
    .reg_rsp_t ( ${soc_regbus_periph_xbar.out_soc_ctrl.rsp_type()} )
  ) i_soc_ctrl (
    .clk_i     ( clk_i  ),
    .rst_ni    ( rst_ni ),
    .reg_req_i ( ${soc_regbus_periph_xbar.out_soc_ctrl.req_name()} ),
    .reg_rsp_o ( ${soc_regbus_periph_xbar.out_soc_ctrl.rsp_name()} ),
    .reg2hw    ( soc_ctrl_in ),
    .hw2reg    ( soc_ctrl_out ),
    .devmode_i ( 1'b1 )
  );

  //////////////
  //   UART   //
  //////////////
  uart #(
    .reg_req_t (${soc_regbus_periph_xbar.out_uart.req_type()} ),
    .reg_rsp_t (${soc_regbus_periph_xbar.out_uart.rsp_type()} )
  ) i_uart (
    .clk_i (${soc_regbus_periph_xbar.out_uart.clk}),
    .rst_ni (${soc_regbus_periph_xbar.out_uart.rst}),
    .reg_req_i (${soc_regbus_periph_xbar.out_uart.req_name()}),
    .reg_rsp_o (${soc_regbus_periph_xbar.out_uart.rsp_name()}),
    .cio_tx_o (uart_tx_o),
    .cio_rx_i (uart_rx_i),
    .cio_tx_en_o (),
    .intr_tx_watermark_o (irq.uart_tx_watermark),
    .intr_rx_watermark_o (irq.uart_rx_watermark),
    .intr_tx_empty_o (irq.uart_tx_empty),
    .intr_rx_overflow_o (irq.uart_rx_overflow),
    .intr_rx_frame_err_o (irq.uart_rx_frame_err),
    .intr_rx_break_err_o (irq.uart_rx_break_err),
    .intr_rx_timeout_o (irq.uart_rx_timeout),
    .intr_rx_parity_err_o (irq.uart_rx_parity_err)
  );

  /////////////
  //   ROM   //
  /////////////

  // This is very system specific, so we might be better off
  // placing it outside the top-level.
  assign bootrom_req_o = ${soc_regbus_periph_xbar.out_bootrom.req_name()};
  assign ${soc_regbus_periph_xbar.out_bootrom.rsp_name()} = bootrom_rsp_i;

  //////////////
  //   PLIC   //
  //////////////
  rv_plic #(
    .reg_req_t (${soc_regbus_periph_xbar.out_plic.req_type()}),
    .reg_rsp_t (${soc_regbus_periph_xbar.out_plic.rsp_type()})
  ) i_rv_plic (
    .clk_i (${soc_regbus_periph_xbar.out_plic.clk}),
    .rst_ni (${soc_regbus_periph_xbar.out_plic.rst}),
    .reg_req_i (${soc_regbus_periph_xbar.out_plic.req_name()}),
    .reg_rsp_o (${soc_regbus_periph_xbar.out_plic.rsp_name()}),
    // TODO(zarubaf): Hook up to interrupt sources.
    .intr_src_i ('0),
    .irq_o (eip),
    .irq_id_o (),
    .msip_o ()
  );

  //////////////////
  //   SPI Host   //
  //////////////////
  spi_host #(
    .reg_req_t (${soc_regbus_periph_xbar.out_spim.req_type()}),
    .reg_rsp_t (${soc_regbus_periph_xbar.out_spim.rsp_type()})
  ) i_spi_host (
    // TODO(zarubaf): Fix clock assignment
    .clk_i  (${soc_regbus_periph_xbar.out_spim.clk}),
    .rst_ni (${soc_regbus_periph_xbar.out_spim.rst}),
    .clk_core_i (${soc_regbus_periph_xbar.out_spim.clk}),
    .rst_core_ni (${soc_regbus_periph_xbar.out_spim.rst}),
    .reg_req_i (${soc_regbus_periph_xbar.out_spim.req_name()}),
    .reg_rsp_o (${soc_regbus_periph_xbar.out_spim.rsp_name()}),
    .cio_sck_o (spim_sck_o),
    .cio_sck_en_o (spim_sck_en_o),
    .cio_csb_o (spim_csb_o),
    .cio_csb_en_o (spim_csb_en_o),
    .cio_sd_o (spim_sd_o),
    .cio_sd_en_o (spim_sd_en_o),
    .cio_sd_i (spim_sd_i),
    .intr_error_o (irq.spim_error),
    .intr_spi_event_o (irq.spim_spi_event)
  );

  //////////////
  //   GPIO   //
  //////////////
  gpio #(
    .reg_req_t (${soc_regbus_periph_xbar.out_gpio.req_type()}),
    .reg_rsp_t (${soc_regbus_periph_xbar.out_gpio.rsp_type()})
  ) i_gpio (
    .clk_i (${soc_regbus_periph_xbar.out_gpio.clk}),
    .rst_ni (${soc_regbus_periph_xbar.out_gpio.rst}),
    .reg_req_i (${soc_regbus_periph_xbar.out_gpio.req_name()}),
    .reg_rsp_o (${soc_regbus_periph_xbar.out_gpio.rsp_name()}),
    .cio_gpio_i (gpio_d_i),
    .cio_gpio_o (gpio_d_o),
    .cio_gpio_en_o (gpio_oe_o),
    .intr_gpio_o (irq.gpio)
  );

  /////////////
  //   I2C   //
  /////////////
  i2c #(
    .reg_req_t (${soc_regbus_periph_xbar.out_i2c.req_type()}),
    .reg_rsp_t (${soc_regbus_periph_xbar.out_i2c.rsp_type()})
  ) i_i2c (
    .clk_i (${soc_regbus_periph_xbar.out_i2c.clk}),
    .rst_ni (${soc_regbus_periph_xbar.out_i2c.rst}),
    .reg_req_i (${soc_regbus_periph_xbar.out_i2c.req_name()}),
    .reg_rsp_o (${soc_regbus_periph_xbar.out_i2c.rsp_name()}),
    .cio_scl_i (i2c_scl_i),
    .cio_scl_o (i2c_scl_o),
    .cio_scl_en_o (i2c_scl_en_o),
    .cio_sda_i (i2c_sda_i),
    .cio_sda_o (i2c_sda_o),
    .cio_sda_en_o (i2c_sda_en_o),
    .intr_fmt_watermark_o (irq.i2c_fmt_watermark),
    .intr_rx_watermark_o (irq.i2c_rx_watermark),
    .intr_fmt_overflow_o (irq.i2c_fmt_overflow),
    .intr_rx_overflow_o (irq.i2c_rx_overflow),
    .intr_nak_o (irq.i2c_nak),
    .intr_scl_interference_o (irq.i2c_scl_interference),
    .intr_sda_interference_o (irq.i2c_sda_interference),
    .intr_stretch_timeout_o (irq.i2c_stretch_timeout),
    .intr_sda_unstable_o (irq.i2c_sda_unstable),
    .intr_trans_complete_o (irq.i2c_trans_complete),
    .intr_tx_empty_o (irq.i2c_tx_empty),
    .intr_tx_nonempty_o (irq.i2c_tx_nonempty),
    .intr_tx_overflow_o (irq.i2c_tx_overflow),
    .intr_acq_overflow_o (irq.i2c_acq_overflow),
    .intr_ack_stop_o (irq.i2c_ack_stop),
    .intr_host_timeout_o (irq.i2c_host_timeout)
  );

endmodule
