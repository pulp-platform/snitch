From 0953cbb1b3c694bd819e774f9b02e9e37056481c Mon Sep 17 00:00:00 2001
From: Paul Scheffler <paulsc@iis.ee.ethz.ch>
Date: Wed, 30 Mar 2022 21:48:25 +0200
Subject: [PATCH] riscv-dbg: func reset and glitch prevention (#123) + doc
 changes

---
 Bender.yml          |   2 +-
 CHANGELOG.md        |   8 ++
 doc/debug-system.md | 196 ++++++++++++++++++++++++++++++++++++++++++++++---
 src/dmi_cdc.sv      |  56 ++++++++------
 src/dmi_intf.sv     |   2 +-
 src/dmi_jtag.sv     | 206 ++++++++++++++++++++++++++++------------------------
 src/dmi_jtag_tap.sv |  11 +--
 7 files changed, 343 insertions(+), 138 deletions(-)

diff --git a/Bender.yml b/Bender.yml
index b6bb6ac..b831929 100644
--- a/Bender.yml
+++ b/Bender.yml
@@ -10,7 +10,7 @@ package:
 
 dependencies:
   tech_cells_generic: { git: "https://github.com/pulp-platform/tech_cells_generic.git", version: 0.2.3 }
-  common_cells: {git: https://github.com/pulp-platform/common_cells.git, version: 1.21.0}
+  common_cells: {git: https://github.com/pulp-platform/common_cells.git, rev: clearable_cdcs}
 
 sources:
   files:
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 6d21973..91ad2d5 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -9,6 +9,14 @@ and this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.
 ### Changed
 ### Fixed
 
+## [0.4.1] - 2021-05-04
+### Added
+### Changed
+### Fixed
+- Remove superfluous helper variable in dm_csrs.sv
+- Synchronized Bender.yml entries
+- Various Lint warnings
+
 ## [0.4.0] - 2020-11-06
 ### Added
 - Added parameter ReadByteEnable that may be disabled to revert SBA _be_ behavior to 0 on reads
diff --git a/doc/debug-system.md b/doc/debug-system.md
index 708aa92..1beca7d 100644
--- a/doc/debug-system.md
+++ b/doc/debug-system.md
@@ -54,24 +54,24 @@ Our implementation only provides a single Debug Module on the DMI bus mapped to
 0x11        | Debug Module Status (dmstatus)               | see table below
 0x12        | Hart Info (hartinfo)
 0x13        | Halt Summary 1 (haltsum1)
-0x14        | Hart Array Window Select (hawindowsel)
-0x15        | Hart Array Window (hawindow)
+0x14        | Hart Array Window Select (hawindowsel)       | Not implemented
+0x15        | Hart Array Window (hawindow)                 | Not implemented
 0x16        | Abstract Control and Status (abstractcs)
 0x17        | Abstract Command (command)
 0x18        | Abstract Command Autoexec (abstractauto)
-0x19        | Configuration String Pointer 0 (confstrptr0)
-0x1a        | Configuration String Pointer 1 (confstrptr1)
-0x1b        | Configuration String Pointer 2 (confstrptr2)
-0x1c        | Configuration String Pointer 3 (confstrptr3)
-0x1d        | Next Debug Module (nextdm)
-0x1f        | Custom Features (custom)
+0x19        | Configuration String Pointer 0 (confstrptr0) | Not implemented
+0x1a        | Configuration String Pointer 1 (confstrptr1) | Not implemented
+0x1b        | Configuration String Pointer 2 (confstrptr2) | Not implemented
+0x1c        | Configuration String Pointer 3 (confstrptr3) | Not implemented
+0x1d        | Next Debug Module (nextdm)                   | Not implemented
+0x1f        | Custom Features (custom)                     | Not implemented
 0x20        | Program Buffer 0 (progbuf0)
 0x2f        | Program Buffer 15 (progbuf15)
-0x30        | Authentication Data (authdata)
-0x32        | Debug Module Control and Status 2 (dmcs2)
+0x30        | Authentication Data (authdata)               | Not implemented
+0x32        | Debug Module Control and Status 2 (dmcs2)    | Not implemented
 0x34        | Halt Summary 2 (haltsum2)
 0x35        | Halt Summary 3 (haltsum3)
-0x37        | System Bus Address 127:96 (sbaddress3)
+0x37        | System Bus Address 127:96 (sbaddress3).      | Not implemented
 0x38        | System Bus Access Control and Status (sbcs)
 0x39        | System Bus Address 31:0 (sbaddress0)
 0x3a        | System Bus Address 63:32 (sbaddress1)
@@ -79,9 +79,11 @@ Our implementation only provides a single Debug Module on the DMI bus mapped to
 0x3c        | System Bus Data 31:0 (sbdata0)
 0x3d        | System Bus Data 63:32 (sbdata1)
 0x3e        | System Bus Data 95:64 (sbdata2)
-0x3f        | System Bus Data 127:96 (sbdata3)
+0x3f        | System Bus Data 127:96 (sbdata3).            | Not implemented
 0x40        | Halt Summary 0 (haltsum0)
 
+Accessing a non-implemented register will return `0`.
+
 ### dmcontrol (0x10)
 
 **Field**       | **Access** | **(Reset) Value** | **Comment**
@@ -451,3 +453,173 @@ Address         | Description
 0x808           | ExceptionAddress. Entry point into the Debug Module. The core must jump to this address when it receives an exception while being in debug mode.
 
 (Note: The debug memory addressing scheme is adopted from the Rocket Chip Generator.)
+
+
+## JTAG Debug Transport Module
+
+The RISC-V specification does not mandate a specific transport mode for the
+debug module. While theoratially debug could be facilitate over any
+memory-mapped protocol the debug specification standardizes the access via a
+IEEE 1149.1 JTAG TAP (Test Access Port) - see [debug spec 0.13 chapter
+6](https://riscv.org/wp-content/uploads/2019/03/riscv-debug-release.pdf).
+
+The JTAG DTM takes care of translating JTAG signals into the custom DMI protocol
+on the debug module's
+[interface](https://github.com/pulp-platform/riscv-dbg/blob/master/doc/debug-system.md#the-debug-module-interface-dmi).
+
+The JTAG DMI TAP contains four registers (so called instruction registers), by
+default the IR register is 5 bits long, but the implementation is parameterized.
+
+- `BYPASS`: TAP is in BYPASS mode.
+- `IDCODE`: Default after reset. Vendor specific ID. The LSB must be `1`, the
+  exact value can be set during implementation via a parameter:
+  ```systemverilog
+  module dmi_jtag_tap #(
+  parameter int unsigned IrLength = 5,
+  // JTAG IDCODE Value
+  parameter logic [31:0] IdcodeValue = 32'h00000001
+  // xxxx             version
+  // xxxxxxxxxxxxxxxx part number
+  // xxxxxxxxxxx      manufacturer id
+  // 1                required by standard
+  ) (
+  ```
+- `DTMCSR`: RISC-V specific control and status register of the JTAG DMI.
+- `DMIACCESS`: Access the debug module's register.
+    - `abits+33:34`: Address
+    - `33:2`: Data
+    - `1:0`: Operation (0 = NOP, 1 = Read from address, 2 = Write data to
+      address)
+
+The implementation is split between:
+
+- `dmi_jtag_tap.sv` which contains the JTAG TAP logic. This implementation can
+  generally be used for any implementation target. Any IEEE 1149.1 compliant
+  device can be attached.
+- `dmi_jtag.sv` which contains the TAP agnostic logic, `IDCODE`, `DTMCSR`, and
+  `DMIACCESS` registers.
+
+### Xilinx Implementation
+
+For Xilinx FPGA implementation which do not have a dedicated user JTAG pins
+exposed, we provide an alternative implementation using `BSCANE2` primitives.
+Those primitives hook into the existing FPGA scan chain (normally used to
+program bitstreams or debug Arm cores) and provide instruction registers which
+are user programmable. The implementation uses three of those user registers to
+make the `IDCODE`, `DTMCSR`, and `DMIACCESS` registers accessible.
+
+- `IDCODE` is mapped to the FPGA ID Code register
+- `DTMCSR` is mapped to user IR 3
+- `DMIACCESS` is mapped to user IR 4
+
+OpenOCD can remap the registers using the config script.
+
+```
+riscv set_ir idcode 0x09
+riscv set_ir dtmcs 0x22
+riscv set_ir dmi 0x23
+```
+
+To find a suitable (or similar) configuration for your adapter you can have a look at OpenOCD's [interface](https://github.com/ntfreak/openocd/tree/master/tcl/interface) configuration snippets.
+
+#### FPGA IR Lengths
+
+The IR length is different between FPGA families. Here is a non exhaustive list should be up-to-date (April 2021):
+
+
+| Device                                                                                                                                                            | IR Length | `IDCODE`   | `DTMCS`    | `DMI`      |
+| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- | ---------- | ---------- | ---------- |
+| `xcku3p`, `xcku9p`, `xcku11p`, `xcku13eg`, `xcku15p`, `xcku5p`, `xcvu3p`, `ku025`, `ku035`, `ku040`, `ku060`, `ku095`, `vu065`, `vu080`, `vu095`                  | 6         | `0x9`      | `0x22`     | `0x23`     |
+| `7a15t`, `7a25t`, `7s15`, `7s100, `, `7a35t`, `7a50t`, `7a75t`, `7a100t`, `7a200t`, `7k70t`, `7k160t`, `7k325t`, `7k355t`, `7k410t`, `7k420t`, `7k480t`, `7v585t` | 6         | `0x9`      | `0x22`     | `0x23`     |
+| `7vx330t`, `7vx415t`, `7vx485t`, `7vx550t`, `7vx690t`, `7vx980t`, `7z010`, `7z015`, `7z020`, `7z030`, `7z035`, `7z045`, `7z007s`, `7z012s`, `7z014s`, `7z100`     | 6         | `0x9`      | `0x22`     | `0x23`     |
+| `xczu9eg`, `xcvu5p`, `xcvu7p`, `ku085`, `ku115`, `vu125`                                                                                                          | 12        | `0x249`    | `0x8a4`    | `0x8e4`    |
+| `xczu3eg`, `xczu4eg`, `xczu5eg`, `xczu7eg`, `xczu2cg`, `xczu3cg`, `xczu4cg`, `xczu5cg`, `xczu6cg`, `xczu7cg`, `xczu9cg`, `xczu5ev`, `xczu11eg`                    | 16        | `0x2492`   | `0x8a49`   | `0x8e49`   |
+| `xczu15eg`, `xczu19eg`, `xczu7ev`, `xczu2eg`, `xczu4ev`, `xczu6eg`, `xczu17eg`                                                                                    | 16        | `0x2492`   | `0x8a49`   | `0x8e49`   |
+| `7vh580t`                                                                                                                                                         | 22        | `0x92492`  | `0x229249` | `0x239249` |
+| `xcvu13p`, `7v2000t`, `7vx1140t`, `xcvu9p`, `xcvu11p`, `vu160`, `vu190`, `vu440`                                                                                  | 24        | `0x249249` | `0x8a4924` | `0x8e4924` |
+| `7vh870t`                                                                                                                                                         | 38        | ?          | ?          | ?          |
+
+#### FPGA `IDCODES`
+
+The four MSBs additional encodes the version of the FPGA. So for `7a15t` version `1` you would get an `IDCODE` of `32'h1362E093` and for version `2` you would get `32'h2362E093` etc.
+
+| Part Nr.   | FPGA ID Code   |     | Part Nr.   | FPGA ID Code   |
+| ---------- | -------------- | --- | ---------- | -------------- |
+| `7a15t`    | `32'h0362E093` |     | `ku095`    | `32'h03844093` |
+| `7a25t`    | `32'h037C2093` |     | `ku115`    | `32'h0390D093` |
+| `7a35t`    | `32'h0362D093` |     | `vu065`    | `32'h03939093` |
+| `7a50t`    | `32'h0362C093` |     | `vu080`    | `32'h03843093` |
+| `7a75t`    | `32'h03632093` |     | `vu095`    | `32'h03842093` |
+| `7a100t`   | `32'h03631093` |     | `vu125`    | `32'h0392D093` |
+| `7a200t`   | `32'h03636093` |     | `vu160`    | `32'h03933093` |
+| `7k70t`    | `32'h03647093` |     | `vu190`    | `32'h03931093` |
+| `7k160t`   | `32'h0364C093` |     | `vu440`    | `32'h0396D093` |
+| `7k325t`   | `32'h03651093` |     | `xcku3p`   | `32'h04A46093` |
+| `7k355t`   | `32'h03747093` |     | `xcku9p`   | `32'h0484A093` |
+| `7k410t`   | `32'h03656093` |     | `xcku11p`  | `32'h04A4E093` |
+| `7k420t`   | `32'h03752093` |     | `xcku13eg` | `32'h04A52093` |
+| `7k480t`   | `32'h03751093` |     | `xcku15p`  | `32'h04A56093` |
+| `7s15`     | `32'h03620093` |     | `xcku5p`   | `32'h04A62093` |
+| `7s100`    | `32'h037C7093` |     | `xcvu3p`   | `32'h04B39093` |
+| `7v585t`   | `32'h03671093` |     | `xczu9eg`  | `32'h04738093` |
+| `7v2000t`  | `32'h036B3093` |     | `xcvu5p`   | `32'h04B2B093` |
+| `7vh580t`  | `32'h036D9093` |     | `xcvu7p`   | `32'h04B29093` |
+| `7vh870t`  | `32'h036DB093` |     | `xczu3eg`  | `32'h04710093` |
+| `7vx330t`  | `32'h03667093` |     | `xczu4eg`  | `32'h04A47093` |
+| `7vx415t`  | `32'h03682093` |     | `xczu5eg`  | `32'h04A46093` |
+| `7vx485t`  | `32'h03687093` |     | `xczu7eg`  | `32'h04A5A093` |
+| `7vx550t`  | `32'h03692093` |     | `xczu2cg`  | `32'h04A43093` |
+| `7vx690t`  | `32'h03691093` |     | `xczu3cg`  | `32'h04A42093` |
+| `7vx980t`  | `32'h03696093` |     | `xczu4cg`  | `32'h04A47093` |
+| `7vx1140t` | `32'h036D5093` |     | `xczu5cg`  | `32'h04A46093` |
+| `7z010`    | `32'h03722093` |     | `xczu6cg`  | `32'h0484B093` |
+| `7z015`    | `32'h0373B093` |     | `xczu7cg`  | `32'h04A5A093` |
+| `7z020`    | `32'h03727093` |     | `xczu9cg`  | `32'h0484A093` |
+| `7z030`    | `32'h0372C093` |     | `xczu5ev`  | `32'h04720093` |
+| `7z035`    | `32'h03732093` |     | `xczu11eg` | `32'h04740093` |
+| `7z045`    | `32'h03731093` |     | `xczu15eg` | `32'h04750093` |
+| `7z100`    | `32'h03736093` |     | `xczu19eg` | `32'h04758093` |
+| `7z007s`   | `32'h03723093` |     | `xczu7ev`  | `32'h04730093` |
+| `7z012s`   | `32'h0373C093` |     | `xczu2eg`  | `32'h04A43093` |
+| `7z014s`   | `32'h03728093` |     | `xczu4ev`  | `32'h04A47093` |
+| `ku025`    | `32'h03824093` |     | `xczu6eg`  | `32'h04A4B093` |
+| `ku035`    | `32'h03823093` |     | `xczu17eg` | `32'h04A57093` |
+| `ku040`    | `32'h03822093` |     | `xcvu9p`   | `32'h04B31093` |
+| `ku060`    | `32'h03919093` |     | `xcvu11p`  | `32'h04B42093` |
+| `ku085`    | `32'h0390F093` |     | `xcvu13p`  | `32'h04B51093` |
+
+#### Example OpenOCD Configuration
+
+##### Zedboard
+
+The Zedboard uses a custom [Digilent SMT2 USB-JTAG](https://github.com/ntfreak/openocd/blob/master/tcl/interface/ftdi/digilent_jtag_smt2.cfg) module. Additionally it contains a second TAP containing the Arm core, the tap can be configured as well to avoid warning related to the undetected TAP.
+
+The FPGA contains a second version Xilinx device `7z020`, hence `IDCODE` (`0x23727093` see list above). Finally, IR Length is 6, mapping the `IDCODE` to `0x09`, `DTMCS` to `0x22` and `DMI` to `0x23` (see list above).
+
+```tcl
+interface ftdi
+transport select jtag
+
+ftdi_vid_pid 0x0403 0x6014
+
+ftdi_layout_init 0x2088 0x3f8b
+ftdi_layout_signal nSRST -data 0x2000
+ftdi_layout_signal GPIO2 -data 0x2000
+ftdi_layout_signal GPIO1 -data 0x0200
+ftdi_layout_signal GPIO0 -data 0x0100
+
+set _CHIPNAME riscv
+jtag newtap $_CHIPNAME cpu -irlen 6 -expected-id 0x23727093
+
+# just to avoid a warning about the auto-detected arm core
+jtag newtap arm_unused tap -irlen 4 -expected-id 0x4ba00477
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME riscv -chain-position $_TARGETNAME -coreid 0x3e0
+
+riscv set_ir idcode 0x09
+riscv set_ir dtmcs 0x22
+riscv set_ir dmi 0x23
+
+adapter_khz     1000
+```
diff --git a/src/dmi_cdc.sv b/src/dmi_cdc.sv
index 4665c91..f9b32bc 100644
--- a/src/dmi_cdc.sv
+++ b/src/dmi_cdc.sv
@@ -20,10 +20,12 @@ module dmi_cdc (
   // JTAG side (master side)
   input  logic             tck_i,
   input  logic             trst_ni,
-
   input  dm::dmi_req_t     jtag_dmi_req_i,
   output logic             jtag_dmi_ready_o,
   input  logic             jtag_dmi_valid_i,
+  input  logic             jtag_dmi_cdc_clear_i, // Synchronous clear signal.
+                                                 // Triggers reset sequencing
+                                                 // accross CDC
 
   output dm::dmi_resp_t    jtag_dmi_resp_o,
   output logic             jtag_dmi_valid_o,
@@ -42,32 +44,40 @@ module dmi_cdc (
   input  logic             core_dmi_valid_i
 );
 
-  cdc_2phase #(.T(dm::dmi_req_t)) i_cdc_req (
-    .src_rst_ni  ( trst_ni          ),
-    .src_clk_i   ( tck_i            ),
-    .src_data_i  ( jtag_dmi_req_i   ),
-    .src_valid_i ( jtag_dmi_valid_i ),
-    .src_ready_o ( jtag_dmi_ready_o ),
 
-    .dst_rst_ni  ( rst_ni           ),
-    .dst_clk_i   ( clk_i            ),
-    .dst_data_o  ( core_dmi_req_o   ),
-    .dst_valid_o ( core_dmi_valid_o ),
-    .dst_ready_i ( core_dmi_ready_i )
+
+  cdc_2phase_clearable #(.T(dm::dmi_req_t)) i_cdc_req (
+    .src_rst_ni  ( trst_ni              ),
+    .src_clear_i ( jtag_dmi_cdc_clear_i ),
+    .src_clk_i   ( tck_i                ),
+    .src_data_i  ( jtag_dmi_req_i       ),
+    .src_valid_i ( jtag_dmi_valid_i     ),
+    .src_ready_o ( jtag_dmi_ready_o     ),
+
+    .dst_rst_ni  ( rst_ni               ),
+    .dst_clear_i ( 1'b0                 ), // No functional reset from core side
+                                           // used (only async).
+    .dst_clk_i   ( clk_i                ),
+    .dst_data_o  ( core_dmi_req_o       ),
+    .dst_valid_o ( core_dmi_valid_o     ),
+    .dst_ready_i ( core_dmi_ready_i     )
   );
 
-  cdc_2phase #(.T(dm::dmi_resp_t)) i_cdc_resp (
-    .src_rst_ni  ( rst_ni           ),
-    .src_clk_i   ( clk_i            ),
-    .src_data_i  ( core_dmi_resp_i  ),
-    .src_valid_i ( core_dmi_valid_i ),
-    .src_ready_o ( core_dmi_ready_o ),
+  cdc_2phase_clearable #(.T(dm::dmi_resp_t)) i_cdc_resp (
+    .src_rst_ni  ( rst_ni               ),
+    .src_clear_i ( 1'b0                 ), // No functional reset from core side
+                                           // used (only async ).
+    .src_clk_i   ( clk_i                ),
+    .src_data_i  ( core_dmi_resp_i      ),
+    .src_valid_i ( core_dmi_valid_i     ),
+    .src_ready_o ( core_dmi_ready_o     ),
 
-    .dst_rst_ni  ( trst_ni          ),
-    .dst_clk_i   ( tck_i            ),
-    .dst_data_o  ( jtag_dmi_resp_o  ),
-    .dst_valid_o ( jtag_dmi_valid_o ),
-    .dst_ready_i ( jtag_dmi_ready_i )
+    .dst_rst_ni  ( trst_ni              ),
+    .dst_clear_i ( jtag_dmi_cdc_clear_i ),
+    .dst_clk_i   ( tck_i                ),
+    .dst_data_o  ( jtag_dmi_resp_o      ),
+    .dst_valid_o ( jtag_dmi_valid_o     ),
+    .dst_ready_i ( jtag_dmi_ready_i     )
   );
 
 endmodule : dmi_cdc
diff --git a/src/dmi_intf.sv b/src/dmi_intf.sv
index 2593ef0..8ebd749 100644
--- a/src/dmi_intf.sv
+++ b/src/dmi_intf.sv
@@ -5,7 +5,7 @@
 // Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>
 
 
-// The DV interface additionally caries a clock signal.
+// The DV interface additionally carries a clock signal.
 interface DMI_BUS_DV #(
   /// The width of the address.
   parameter int ADDR_WIDTH = -1
diff --git a/src/dmi_jtag.sv b/src/dmi_jtag.sv
index 70ee776..e1bc369 100644
--- a/src/dmi_jtag.sv
+++ b/src/dmi_jtag.sv
@@ -47,22 +47,26 @@ module dmi_jtag #(
   dmi_error_e error_d, error_q;
 
   logic tck;
-  logic trst_n;
+  logic jtag_dmi_clear; // Synchronous reset of DMI triggered by TestLogicReset in
+                        // jtag TAP
+  logic dmi_clear; // Functional (warm) reset of the entire DMI
   logic update;
   logic capture;
   logic shift;
   logic tdi;
 
+  logic dtmcs_select;
+
+  assign dmi_clear = jtag_dmi_clear || (dtmcs_select && update && dtmcs_q.dmihardreset);
+
   // -------------------------------
   // Debug Module Control and Status
   // -------------------------------
-  logic dtmcs_select;
 
   dm::dtmcs_t dtmcs_d, dtmcs_q;
 
   always_comb begin
-    dtmcs_d  = dtmcs_q;
-
+    dtmcs_d = dtmcs_q;
     if (capture) begin
       if (dtmcs_select) begin
         dtmcs_d  = '{
@@ -83,8 +87,8 @@ module dmi_jtag #(
     end
   end
 
-  always_ff @(posedge tck or negedge trst_n) begin
-    if (!trst_n) begin
+  always_ff @(posedge tck or negedge trst_ni) begin
+    if (!trst_ni) begin
       dtmcs_q <= '0;
     end else begin
       dtmcs_q <= dtmcs_d;
@@ -94,9 +98,8 @@ module dmi_jtag #(
   // ----------------------------
   // DMI (Debug Module Interface)
   // ----------------------------
-  // TODO(zarubaf): Might need to be connected to the `dtmcs_q.dmihardreset`
-  // signal.
-  assign dmi_rst_no = rst_ni;
+
+  assign dmi_rst_no = dmi_clear;
 
   logic        dmi_select;
   logic        dmi_tdo;
@@ -142,79 +145,86 @@ module dmi_jtag #(
 
     dmi_req_valid = 1'b0;
 
-    unique case (state_q)
-      Idle: begin
-        // make sure that no error is sticky
-        if (dmi_select && update && (error_q == DMINoError)) begin
-          // save address and value
-          address_d = dmi.address;
-          data_d = dmi.data;
-          if (dm::dtm_op_e'(dmi.op) == dm::DTM_READ) begin
-            state_d = Read;
-          end else if (dm::dtm_op_e'(dmi.op) == dm::DTM_WRITE) begin
-            state_d = Write;
+    if (dmi_clear) begin
+      state_d   = Idle;
+      data_d    = '0;
+      error_d   = DMINoError;
+      address_d = '0;
+    end else begin
+      unique case (state_q)
+        Idle: begin
+          // make sure that no error is sticky
+          if (dmi_select && update && (error_q == DMINoError)) begin
+            // save address and value
+            address_d = dmi.address;
+            data_d = dmi.data;
+            if (dm::dtm_op_e'(dmi.op) == dm::DTM_READ) begin
+              state_d = Read;
+            end else if (dm::dtm_op_e'(dmi.op) == dm::DTM_WRITE) begin
+              state_d = Write;
+            end
+            // else this is a nop and we can stay here
           end
-          // else this is a nop and we can stay here
         end
-      end
 
-      Read: begin
-        dmi_req_valid = 1'b1;
-        if (dmi_req_ready) begin
-          state_d = WaitReadValid;
+        Read: begin
+          dmi_req_valid = 1'b1;
+          if (dmi_req_ready) begin
+            state_d = WaitReadValid;
+          end
         end
-      end
 
-      WaitReadValid: begin
-        // load data into register and shift out
-        if (dmi_resp_valid) begin
-          data_d = dmi_resp.data;
-          state_d = Idle;
+        WaitReadValid: begin
+          // load data into register and shift out
+          if (dmi_resp_valid) begin
+            data_d = dmi_resp.data;
+            state_d = Idle;
+          end
         end
-      end
 
-      Write: begin
-        dmi_req_valid = 1'b1;
-        // request sent, wait for response before going back to idle
-        if (dmi_req_ready) begin
-          state_d = WaitWriteValid;
+        Write: begin
+          dmi_req_valid = 1'b1;
+          // request sent, wait for response before going back to idle
+          if (dmi_req_ready) begin
+            state_d = WaitWriteValid;
+          end
         end
-      end
 
-      WaitWriteValid: begin
-        // got a valid answer go back to idle
-        if (dmi_resp_valid) begin
-          state_d = Idle;
+        WaitWriteValid: begin
+          // got a valid answer go back to idle
+          if (dmi_resp_valid) begin
+            state_d = Idle;
+          end
         end
-      end
 
-      default: begin
-        // just wait for idle here
-        if (dmi_resp_valid) begin
-          state_d = Idle;
+        default: begin
+          // just wait for idle here
+          if (dmi_resp_valid) begin
+            state_d = Idle;
+          end
         end
-      end
-    endcase
+      endcase
 
-    // update means we got another request but we didn't finish
-    // the one in progress, this state is sticky
-    if (update && state_q != Idle) begin
-      error_dmi_busy = 1'b1;
-    end
+      // update means we got another request but we didn't finish
+      // the one in progress, this state is sticky
+      if (update && state_q != Idle) begin
+        error_dmi_busy = 1'b1;
+      end
 
-    // if capture goes high while we are in the read state
-    // or in the corresponding wait state we are not giving back a valid word
-    // -> throw an error
-    if (capture && state_q inside {Read, WaitReadValid}) begin
-      error_dmi_busy = 1'b1;
-    end
+      // if capture goes high while we are in the read state
+      // or in the corresponding wait state we are not giving back a valid word
+      // -> throw an error
+      if (capture && state_q inside {Read, WaitReadValid}) begin
+        error_dmi_busy = 1'b1;
+      end
 
-    if (error_dmi_busy) begin
-      error_d = DMIBusy;
-    end
-    // clear sticky error flag
-    if (update && dtmcs_q.dmireset && dtmcs_select) begin
-      error_d = DMINoError;
+      if (error_dmi_busy) begin
+        error_d = DMIBusy;
+      end
+      // clear sticky error flag
+      if (update && dtmcs_q.dmireset && dtmcs_select) begin
+        error_d = DMINoError;
+      end
     end
   end
 
@@ -223,27 +233,30 @@ module dmi_jtag #(
 
   always_comb begin : p_shift
     dr_d    = dr_q;
-
-    if (capture) begin
-      if (dmi_select) begin
-        if (error_q == DMINoError && !error_dmi_busy) begin
-          dr_d = {address_q, data_q, DMINoError};
-        // DMI was busy, report an error
-        end else if (error_q == DMIBusy || error_dmi_busy) begin
-          dr_d = {address_q, data_q, DMIBusy};
+    if (dmi_clear) begin
+      dr_d = '0;
+    end else begin
+      if (capture) begin
+        if (dmi_select) begin
+          if (error_q == DMINoError && !error_dmi_busy) begin
+            dr_d = {address_q, data_q, DMINoError};
+            // DMI was busy, report an error
+          end else if (error_q == DMIBusy || error_dmi_busy) begin
+            dr_d = {address_q, data_q, DMIBusy};
+          end
         end
       end
-    end
 
-    if (shift) begin
-      if (dmi_select) begin
-        dr_d = {tdi, dr_q[$bits(dr_q)-1:1]};
+      if (shift) begin
+        if (dmi_select) begin
+          dr_d = {tdi, dr_q[$bits(dr_q)-1:1]};
+        end
       end
     end
   end
 
-  always_ff @(posedge tck or negedge trst_n) begin
-    if (!trst_n) begin
+  always_ff @(posedge tck or negedge trst_ni) begin
+    if (!trst_ni) begin
       dr_q      <= '0;
       state_q   <= Idle;
       address_q <= '0;
@@ -273,7 +286,7 @@ module dmi_jtag #(
     .tdo_oe_o,
     .testmode_i,
     .tck_o          ( tck              ),
-    .trst_no        ( trst_n           ),
+    .dmi_clear_o    ( jtag_dmi_clear   ),
     .update_o       ( update           ),
     .capture_o      ( capture          ),
     .shift_o        ( shift            ),
@@ -289,23 +302,24 @@ module dmi_jtag #(
   // ---------
   dmi_cdc i_dmi_cdc (
     // JTAG side (master side)
-    .tck_i             ( tck              ),
-    .trst_ni           ( trst_n           ),
-    .jtag_dmi_req_i    ( dmi_req          ),
-    .jtag_dmi_ready_o  ( dmi_req_ready    ),
-    .jtag_dmi_valid_i  ( dmi_req_valid    ),
-    .jtag_dmi_resp_o   ( dmi_resp         ),
-    .jtag_dmi_valid_o  ( dmi_resp_valid   ),
-    .jtag_dmi_ready_i  ( dmi_resp_ready   ),
+    .tck_i                ( tck              ),
+    .trst_ni              ( trst_ni          ),
+    .jtag_dmi_cdc_clear_i ( dmi_clear        ),
+    .jtag_dmi_req_i       ( dmi_req          ),
+    .jtag_dmi_ready_o     ( dmi_req_ready    ),
+    .jtag_dmi_valid_i     ( dmi_req_valid    ),
+    .jtag_dmi_resp_o      ( dmi_resp         ),
+    .jtag_dmi_valid_o     ( dmi_resp_valid   ),
+    .jtag_dmi_ready_i     ( dmi_resp_ready   ),
     // core side
     .clk_i,
     .rst_ni,
-    .core_dmi_req_o    ( dmi_req_o        ),
-    .core_dmi_valid_o  ( dmi_req_valid_o  ),
-    .core_dmi_ready_i  ( dmi_req_ready_i  ),
-    .core_dmi_resp_i   ( dmi_resp_i       ),
-    .core_dmi_ready_o  ( dmi_resp_ready_o ),
-    .core_dmi_valid_i  ( dmi_resp_valid_i )
+    .core_dmi_req_o       ( dmi_req_o        ),
+    .core_dmi_valid_o     ( dmi_req_valid_o  ),
+    .core_dmi_ready_i     ( dmi_req_ready_i  ),
+    .core_dmi_resp_i      ( dmi_resp_i       ),
+    .core_dmi_ready_o     ( dmi_resp_ready_o ),
+    .core_dmi_valid_i     ( dmi_resp_valid_i )
   );
 
 endmodule : dmi_jtag
diff --git a/src/dmi_jtag_tap.sv b/src/dmi_jtag_tap.sv
index b986837..eff8a38 100644
--- a/src/dmi_jtag_tap.sv
+++ b/src/dmi_jtag_tap.sv
@@ -34,7 +34,8 @@ module dmi_jtag_tap #(
   input  logic        testmode_i,
   // JTAG is interested in writing the DTM CSR register
   output logic        tck_o,
-  output logic        trst_no,
+  // Synchronous reset of the dmi module triggered by JTAG TAP
+  output logic        dmi_clear_o,
   output logic        update_o,
   output logic        capture_o,
   output logic        shift_o,
@@ -174,12 +175,12 @@ module dmi_jtag_tap #(
   // ----------------
   logic tck_n, tck_ni;
 
-  tc_clk_inverter i_tck_inv (
+  cluster_clock_inverter i_tck_inv (
     .clk_i ( tck_i  ),
     .clk_o ( tck_ni )
   );
 
-  tc_clk_mux2 i_dft_tck_mux (
+  pulp_clock_mux2 i_dft_tck_mux (
     .clk0_i    ( tck_ni     ),
     .clk1_i    ( tck_i      ), // bypass the inverted clock for testing
     .clk_sel_i ( testmode_i ),
@@ -202,7 +203,7 @@ module dmi_jtag_tap #(
   // Determination of next state; purely combinatorial
   always_comb begin : p_tap_fsm
 
-    trst_no            = trst_ni;
+    dmi_clear_o        = 1'b0;
 
     capture_dr         = 1'b0;
     shift_dr           = 1'b0;
@@ -216,7 +217,7 @@ module dmi_jtag_tap #(
     unique case (tap_state_q)
       TestLogicReset: begin
         tap_state_d = (tms_i) ? TestLogicReset : RunTestIdle;
-        trst_no = 1'b1;
+        dmi_clear_o = 1'b1;
       end
       RunTestIdle: begin
         tap_state_d = (tms_i) ? SelectDrScan : RunTestIdle;
-- 
2.16.5

